# coding=utf-8
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

import plpy
import math

from madlib_keras_validator import MstLoaderInputValidator
from utilities.utilities import add_postfix, extract_keyvalue_params, _assert
from utilities.control import MinWarning
from madlib_keras_fit_multiple_model import FitMultipleModel
from madlib_keras_model_selection import MstSearch

class AutoMLSchema:
    BRACKET = 's'
    ROUND = 'i'
    CONFIGURATIONS = 'n_i'
    RESOURCES = 'r_i'
    HYPERBAND = 'hyperband'
    R = 'R'
    ETA = 'eta'
    SKIP_LAST = 'skip_last'


@MinWarning("warning")
class HyperbandSchedule():
    """The utility class for loading a hyperband schedule table with algorithm inputs.

    Attributes:
        schedule_table (string): Name of output table containing hyperband schedule.
        R (int): Maximum number of resources (iterations) that can be allocated
  to a single configuration.
        eta (int): Controls the proportion of configurations discarded in
  each round of successive halving.
        skip_last (int): The number of last rounds to skip.
    """
    def __init__(self, schedule_table, R, eta=3, skip_last=0):
        self.schedule_table = schedule_table # table name to store hyperband schedule
        self.R = R # maximum iterations/epochs allocated to a configuration
        self.eta = eta # defines downsampling rate
        self.skip_last = skip_last
        self.validate_inputs()

        # number of unique executions of Successive Halving (minus one)
        self.s_max = int(math.floor(math.log(self.R, self.eta)))
        self.validate_s_max()
        # total number of resources/iterations (without reuse) per execution of Succesive Halving (n,r)
        self.B = (self.s_max + 1) * self.R

        self.schedule_vals = []

        self.calculate_schedule()

    def load(self):
        """
        The entry point for loading the hyperband schedule table.
        """
        self.create_schedule_table()
        self.insert_into_schedule_table()

    def validate_inputs(self):
        """
        Validates user input values
        """
        _assert(self.eta > 1, "DL: eta must be greater than 1")
        _assert(self.R >= self.eta, "DL: R should not be less than eta")

    def validate_s_max(self):
        _assert(self.skip_last >= 0 and self.skip_last < self.s_max+1, "DL: skip_last must be " +
                "non-negative and less than {0}".format(self.s_max))

    def calculate_schedule(self):
        """
        Calculates the hyperband schedule (number of configs and allocated resources)
        in each round of each bracket and skips the number of last rounds specified in 'skip_last'
        """
        for s in reversed(range(self.s_max+1)):
            n = int(math.ceil(int(self.B/self.R/(s+1))*math.pow(self.eta, s))) # initial number of configurations
            r = self.R * math.pow(self.eta, -s)

            for i in range((s+1) - int(self.skip_last)):
                # Computing each of the
                n_i = n*math.pow(self.eta, -i)
                r_i = r*math.pow(self.eta, i)

                self.schedule_vals.append({AutoMLSchema.BRACKET: s,
                                           AutoMLSchema.ROUND: i,
                                           AutoMLSchema.CONFIGURATIONS: int(n_i),
                                           AutoMLSchema.RESOURCES: int(round(r_i))})

    def create_schedule_table(self):
        """Initializes the output schedule table"""
        create_query = """
                        CREATE TABLE {self.schedule_table} (
                            {s} INTEGER,
                            {i} INTEGER,
                            {n_i} INTEGER,
                            {r_i} INTEGER,
                            unique ({s}, {i})
                        );
                       """.format(self=self,
                                  s=AutoMLSchema.BRACKET,
                                  i=AutoMLSchema.ROUND,
                                  n_i=AutoMLSchema.CONFIGURATIONS,
                                  r_i=AutoMLSchema.RESOURCES)
        with MinWarning('warning'):
            plpy.execute(create_query)

    def insert_into_schedule_table(self):
        """Insert every thing in self.schedule_vals into the output schedule table."""
        for sd in self.schedule_vals:
            sd_s = sd[AutoMLSchema.BRACKET]
            sd_i = sd[AutoMLSchema.ROUND]
            sd_n_i = sd[AutoMLSchema.CONFIGURATIONS]
            sd_r_i = sd[AutoMLSchema.RESOURCES]
            insert_query = """
                            INSERT INTO
                                {self.schedule_table}(
                                    {s_col},
                                    {i_col},
                                    {n_i_col},
                                    {r_i_col}
                                )
                            VALUES (
                                {sd_s},
                                {sd_i},
                                {sd_n_i},
                                {sd_r_i}
                            )
                           """.format(s_col=AutoMLSchema.BRACKET,
                                      i_col=AutoMLSchema.ROUND,
                                      n_i_col=AutoMLSchema.CONFIGURATIONS,
                                      r_i_col=AutoMLSchema.RESOURCES,
                                      **locals())
            plpy.execute(insert_query)


@MinWarning("warning")
class KerasAutoML():
    """TODO"""
    def __init__(self, source_table, model_output_table, model_arch_table, model_selection_table,
                 model_id_list, compile_params_grid, fit_params_grid, automl_method='hyperband',
                 automl_params='R=81, eta=3, skip_last=0', random_state=None, object_table=None,
                 use_gpus=False, validation_table=None, metrics_compute_frequency=None,
                 name=None, description=None):
        self.source_table = source_table
        self.model_output_table = model_output_table

        self.model_arch_table = model_arch_table
        self.model_selection_table = model_selection_table
        self.model_selection_summary_table = add_postfix(
            model_selection_table, "_summary")
        self.model_id_list = sorted(list(set(model_id_list)))

        self.compile_params_grid = compile_params_grid
        self.fit_params_grid = fit_params_grid

        # needed?
        MstLoaderInputValidator(
            model_arch_table=self.model_arch_table,
            model_selection_table=self.model_selection_table,
            model_selection_summary_table=self.model_selection_summary_table,
            model_id_list=self.model_id_list,
            compile_params_list=compile_params_grid,
            fit_params_list=fit_params_grid,
            object_table=object_table,
            module_name='madlib_keras_automl'
        )

        self.automl_method = automl_method
        self.automl_params = automl_params
        self.random_state = random_state

        self.validate_and_define_inputs()

        self.object_table = object_table
        self.use_gpus = use_gpus
        self.validation_table = validation_table
        self.metrics_compute_frequency = metrics_compute_frequency # default value TODO ?
        self.name = name
        self.description = description

        if AutoMLSchema.HYPERBAND.startswith(self.automl_method.lower()):
            self.find_hyperband_config()


    def load(self):
        self.create_model_output_table()
        self.create_model_output_summary_table()
        self.create_model_output_info_table()
        self.create_model_selection_table()
        self.create_model_selection_summary_table()

    def validate_and_define_inputs(self):
        # explicit checks for generate_model_configs function params here
        # or during function call itself ?? TODO
        # similarly for some multiple fit params
        automl_params_dict = extract_keyvalue_params(self.automl_params,
                                                     default_values={'R': 81, 'eta': 3, 'skip_last': 0},
                                                     lower_case_names=False)
        for i in automl_params_dict:
            automl_params_dict[i] = int(automl_params_dict[i])
        plpy.info(automl_params_dict)

        if AutoMLSchema.HYPERBAND.startswith(self.automl_method.lower()):
            _assert(len(automl_params_dict) >= 1 or len(automl_params_dict) <= 3,
                    "DL: Only R, eta, and skip_last may be specified")
            if AutoMLSchema.R not in automl_params_dict:\
                plpy.error("DL: 'R' needs to be specified in 'automl_params' for hyperband")
            for i in automl_params_dict:
                if i == AutoMLSchema.R:
                    self.R = automl_params_dict[AutoMLSchema.R]
                elif i == AutoMLSchema.ETA:
                    self.eta = automl_params_dict[AutoMLSchema.ETA]
                elif i == AutoMLSchema.SKIP_LAST:
                    self.skip_last = automl_params_dict[AutoMLSchema.SKIP_LAST]
                else:
                    plpy.error("DL: {0} is an invalid param".format(i))
            self.s_max = int(math.floor(math.log(self.R, self.eta)))
            _assert(self.skip_last >= 0 and self.skip_last < self.s_max+1, "DL: skip_last must be " +
                    "non-negative and less than {0}".format(self.s_max))
            # total number of resources/iterations (without reuse) per execution of Succesive Halving (n,r)
            self.B = (self.s_max + 1) * self.R
        else:
            plpy.error("DL: Only hyperband is supported as the automl method")

    def find_hyperband_config(self):
        initial_vals = {}
        n_vals = []
        # get hyper parameter configs for each s
        for s in reversed(range(self.s_max+1)):

            n = int(math.ceil(int(self.B/self.R/(s+1))*math.pow(self.eta, s))) # initial number of configurations
            r = self.R * math.pow(self.eta, -s) # initial number of iterations to run configurations for

            initial_vals[s] = (n, r)
            n_vals.append(n)

            # print ("s=" + str(s))
            # print ("n=" + str(n))
            # print ("r=" + str(r))
            # print (" ")

        # print ("outer loop on diagonal:")
        # outer loop on diagonal

        # random_search = MstSearch(self.model_arch_table,
        #           self.model_selection_table,
        #           self.model_id_list,
        #           self.compile_params_grid,
        #           self.fit_params_grid,
        #           search_type='random',
        #           self.num_configs=sum(initial_vals.keys()),
        #           self.random_state,
        #           self.object_table)
        # random_search.load() # for populating mst table

        # grouping_query = "ALTER TABLE {self.model_selection_table} ADD COLUMN s_group VARCHAR;" \
        # "INSERT INTO {self.model_selection_table} (s_group) SELECT CASE ".format(**locals())
        # case_string = ""
        # for s_val in range(self.s_max+1):
        #     case_string += "WHEN mst_key >= {sum(n_vals[:s_val])+1} AND mst_key <= {sum(n_vals[:s_val+1])} " \
        #                    "THEN {self.s_max - s_val} ".format(**locals())
        # grouping_query += case_string + "END AS s_group FROM {self.model_selection_table};".format(**locals())
        #
        # plpy.execute(grouping_query)

        for i in range((self.s_max+1) - int(self.skip_last)):
            # print (" ")
            # print ("i=" + str(i))
            #
            # print ("inner loop on s desc:")
            # inner loop on s desc
            plpy.info("----i={0}----".format(i))
            temp_lst = []
            for s in range(self.s_max, self.s_max-i-1, -1):
                n, r = initial_vals[s]
                n_i = n * math.pow(self.eta, -i+self.s_max-s)
                r_i = r * math.pow(self.eta, i-self.s_max+s))

                # print ("s=" + str(s))
                # print ("n_i=" + str(n_i))
                # print ("r_i=" + str(r_i))

                temp_lst.append("s={0},n_i={1},r_i={2}".format(s, int(n_i), int(round(r_i))))
                # plpy.info("s={0},n_i={1},r_i={2}".format(s, n_i, r_i))
            plpy.info('\n' + '\n'.join(temp_lst))

    def create_model_output_table(self):
        pass
    def create_model_output_summary_table(self):
        pass
    def create_model_output_info_table(self):
        pass
    def create_model_selection_table(self):
        pass
    def create_model_selection_summary_table(self):
        pass
